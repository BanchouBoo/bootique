#!/bin/sh
# TODO: Replace getopt with getopts or custom parsing, for portability

CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}"
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}"

THEME_DIR="${BOOTIQUE_THEME_DIR:-$CONFIG_DIR/bootique/themes}"
TEMPLATE_DIR="${BOOTIQUE_TEMPLATE_DIR:-$CONFIG_DIR/bootique/templates}"
OUTPUT_DIR="${BOOTIQUE_OUTPUT_DIR:-$CACHE_DIR/bootique/theme}"
DMENU_COMMAND="${BOOTIQUE_DMENU_COMMAND:-dmenu -i -p Theme}"

uname | grep -q -i 'bsd' && BSD=true

die() {
    >&2 printf "[\033[0;31mERROR\033[0m] %s\n" "$*"
    exit 1
}

# Remove comments, empty lines, and unnecesary whitespace
to_parsable() {
	sed -e 's/!.*$//' -e '/^[[:space:]]*$/d' \
	-e 's/:[[:space:]]*/:/' -e 's/^[[:space:]]*//' "$@"
}

parse_template() {
	theme="$1"
	template="$2"
	template_contents=$(cat "$template")

	while read -r line; do
		key=${line%%:*}
		value=${line#*:}

		template_contents=$(echo "$template_contents" | sed "s@<$key>@$value@g")
	done << THEME
		$(to_parsable "$theme")
THEME

	while read -r line; do
		[ "$line" ] || continue
		line="${line#*<}"
		line="${line%?}"
		command="${line%%:*}"
		args="${line#*:}"
		if command -v "$command" > /dev/null; then
			value=$(eval "$command" "$args")
			template_contents=$(echo "$template_contents" | sed "s@<$line>@$value@")
		else
			die "'$command' does not exist!"
		fi
	done << MODS
		$(echo "$template_contents" | grep "<[^>]*:[^>]*>")
MODS

	echo "$template_contents"
}

changetheme() {
	filefromtemplate() {
		filename="${2##*/}"
		filename="${filename%.*}"
		outputfile=$(parse_template "$1" "$2")
		outputpath="$OUTPUT_DIR/$filename"

		if [ "$outputfile" ]; then
			[ -d "$OUTPUT_DIR" ] || mkdir -p "$OUTPUT_DIR"

			fileexec=$(echo "$outputfile" | grep "[[:space:]]*booexec" \
			| sed 's@<file>@'"$outputpath"'@g')

			outputfile=$(echo "$outputfile" | sed '/^booexec/d')
			echo "$outputfile" > "$outputpath"

			echo "$fileexec" | while read -r line; do
				eval "${line#*:}"
			done
		fi
	}

	[ -f "$1" ] || die "$1 is not a file"

	theme="$1"
	template_target="${2:-$TEMPLATE_DIR}"

	if [ -f "$template_target" ]; then
		filefromtemplate "$1" "$template_target"
	elif [ -d "$template_target" ]; then
		templates=$(find "$template_target" -name "*.template")
		for template in $templates; do
			filefromtemplate "$theme" "$template"
		done
	else
		die "Invalid template target"
	fi
}

menu() {
	COMMAND_BASE="${DMENU_COMMAND%% *}"
	if [ ! "$(command -v $COMMAND_BASE)" ]; then
        die "dmenu command '$COMMAND_BASE' not installed"
	fi

	cd "$THEME_DIR" || exit 1

	theme=$(find . -name '*.theme' | sed 's:\./::g' | $DMENU_COMMAND)
	changetheme "$theme" "$1"

	exit
}

help() {
	[ "$BSD" ] && >&2 echo "WARN: long opts (--theme, etc) do not work on BSD!"
>&2 cat <<"EOF"
Options:
    -h, --help
    	display this help page

    -t, --theme <theme path>
    	target theme file used to parse templates (not used with --menu)

    -p, --template <template path>
    	target template file or directory that the theme will be applied to, if not set then $BOOTIQUE_TEMPLATE_DIR will be used

    -m, --menu
    	select the theme from a list using $BOOTIQUE_DMENU_COMMAND populated with files from $BOOTIQUE_THEME_DIR

Evironment variables:
    BOOTIQUE_THEME_DIR
    	directory where themes are stored, used for the --menu option
        DEFAULT = $XDG_CONFIG_HOME/bootique/themes

    BOOTIQUE_TEMPLATE_DIR
    	directory where templates are stored, used when no template file or directory is provided
        DEFAULT = $XDG_CONFIG_HOME/bootique/templates

    BOOTIQUE_OUTPUT_DIR
    	directory where theme files are output
        DEFAULT = $XDG_CACHE_HOME/bootique/theme

    BOOTIQUE_DMENU_COMMAND
    	command used for the --menu option, can be any command that accepts newline-delimited piped input such as dmenu, rofi, fzf, etc.
        DEFAULT = dmenu -i -p Theme
EOF
	exit "${1:-0}"
}

[ "$1" ] || help

if [ "$BSD" ]; then
	options="$(getopt 't:p:hm' "$@")"
else
	options="$(getopt -n 'bootique' -s sh -o 't:p:hm' -l 'theme:,template:,menu,help' -- "$@")"
fi

# If invalid options
[ $? -eq 0 ] || help 1

set -- $options

template="$TEMPLATE_DIR"

# Parse options
while [ "$1" ]; do
	case "$1" in
		-h|--help)
			help
			break
			;;
		-m|--menu)
			menu=true
			;;
		-t|--theme)
			theme="$(echo "$2" | tr -d \')"
			shift
			;;
		-p|--template)
			template="$(echo "$2" | tr -d \')"
			shift
			;;
		--)
			shift
			break
			;;
		*)
			break
			;;
		esac
	shift
done

if [ "$menu" = true ]; then
	menu "$template"
elif [ "$theme" ]; then
	changetheme "$theme" "$template"
fi
